#### 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

***1.原码:***  
一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码.  
比如:   
00000000 00000000 00000000 00000101 是 5的   
10000000 00000000 00000000 00000101 是 -5的 原码。  
***2.反码***   
正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反[每一位取反(除符号位)]。       
比如：  
正数00000000 00000000 00000000 00000101  的反码还是 00000000 00000000 00000000 00000101  
负数10000000 00000000 00000000 00000101  的反码则是 11111111 11111111 11111111 11111010。  
***3.补码***  
正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.
比如：10000000 00000000 00000000 00000101 的补码是：11111111 11111111 11111111 11111010。
那么，补码为：
11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011
备注：1、从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。
      2、补码却规定0没有正负之分
所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。


##### 最优解  
一个二进制数比如1100 减一后得到的数是把从最右边1开始所有的取反  
得到1011，这时候如果把原来的数与减一后的数做与运算1100 & 1011  
得到1000.重复此过程1000 & 0111 = 0000  
即终止条件就是判断结果是否为0.循环的次数就是1的个数  
```c
public class Solution {
    public int NumberOf1(int n) {
        int count = 0;
        while(n!= 0){
            count++;
            n = n & (n - 1);
         }
        return count;
    }
}
```
